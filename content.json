{"meta":{"title":"Point's Blog","subtitle":null,"description":null,"author":"Point Tang","url":"http://pointtang.github.io"},"pages":[{"title":"","date":"2019-12-13T10:48:39.082Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"about/index.html","permalink":"http://pointtang.github.io/about/index.html","excerpt":"","text":"About MeThis is Point. Try my best to be a better point."},{"title":"categories","date":"2018-05-21T15:50:19.000Z","updated":"2019-12-13T10:48:39.082Z","comments":false,"path":"categories/index.html","permalink":"http://pointtang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Hello World","date":"2019-12-13T10:48:39.082Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"point/hello.html","permalink":"http://pointtang.github.io/point/hello.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"","date":"2019-12-13T10:48:39.082Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"point/index.html","permalink":"http://pointtang.github.io/point/index.html","excerpt":"","text":"Secret | Point&#39;s Blog I’m Point. This is my secreat space. Hello, I&#39;m Point. This is my blog, for some experiences of coding. Powered by hexo and Theme by Jacman © 2018 Point Tang $(document).ready(function(){ $('.navbar').click(function(){ $('header nav').toggleClass('shownav'); }); var myWidth = 0; function getSize(){ if( typeof( window.innerWidth ) == 'number' ) { myWidth = window.innerWidth; } else if( document.documentElement && document.documentElement.clientWidth) { myWidth = document.documentElement.clientWidth; }; }; var m = $('#main'), a = $('#asidepart'), c = $('.closeaside'), o = $('.openaside'); c.click(function(){ a.addClass('fadeOut').css('display', 'none'); o.css('display', 'block').addClass('fadeIn'); m.addClass('moveMain'); }); o.click(function(){ o.css('display', 'none').removeClass('beforeFadeIn'); a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn'); m.removeClass('moveMain'); }); $(window).scroll(function(){ o.css(\"top\",Math.max(80,260-$(this).scrollTop())); }); $(window).resize(function(){ getSize(); if (myWidth >= 1024) { $('header nav').removeClass('shownav'); }else{ m.removeClass('moveMain'); a.css('display', 'block').removeClass('fadeOut'); o.css('display', 'none'); $('#toc.toc-aside').css('display', 'none'); } }); }); $(document).ready(function(){ var ai = $('.article-content>iframe'), ae = $('.article-content>embed'), t = $('#toc'), ta = $('#toc.toc-aside'), o = $('.openaside'), c = $('.closeaside'); if(ai.length>0){ ai.wrap(''); }; if(ae.length>0){ ae.wrap(''); }; c.click(function(){ ta.css('display', 'block').addClass('fadeIn'); }); o.click(function(){ ta.css('display', 'none'); }); $(window).scroll(function(){ ta.css(\"top\",Math.max(140,320-$(this).scrollTop())); }); }); $(document).ready(function(){ var $this = $('.share'), url = $this.attr('data-url'), encodedUrl = encodeURIComponent(url), title = $this.attr('data-title'), tsina = $this.attr('data-tsina'), description = $this.attr('description'); var html = [ '', '', '', '', '', '', '', '' ].join(''); $this.append(html); $('.hoverqrcode').hide(); var myWidth = 0; function updatehoverqrcode(){ if( typeof( window.innerWidth ) == 'number' ) { myWidth = window.innerWidth; } else if( document.documentElement && document.documentElement.clientWidth) { myWidth = document.documentElement.clientWidth; }; var qrsize = myWidth > 1024 ? 200:100; var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1}; var p = $('.article-share-qrcode').position(); $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize) .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10) .qrcode(options); }; $(window).resize(function(){ $('.hoverqrcode').hide(); }); $('.article-share-qrcode').click(function(){ updatehoverqrcode(); $('.hoverqrcode').toggle(); }); $('.article-share-qrcode').hover(function(){}, function(){ $('.hoverqrcode').hide(); }); }); $(document).ready(function(){ $('.article-content').each(function(i){ $(this).find('img').each(function(){ if ($(this).parent().hasClass('fancybox')) return; var alt = this.alt; if (alt) $(this).after('' + alt + ''); $(this).wrap(''); }); $(this).find('.fancybox').each(function(){ $(this).attr('rel', 'article' + i); }); }); if($.fancybox){ $('.fancybox').fancybox(); } });"},{"title":"tags","date":"2018-05-21T15:44:15.000Z","updated":"2019-12-13T10:48:39.082Z","comments":false,"path":"tags/index.html","permalink":"http://pointtang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android碎片知识","slug":"Android碎片知识","date":"2019-12-13T18:32:00.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/12/13/Android碎片知识/","link":"","permalink":"http://pointtang.github.io/2019/12/13/Android%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/","excerpt":"Android碎片记录。","text":"Android碎片记录。 SQLite文件为什么那么大？引用自别人的博客：https://www.cnblogs.com/liaocheng/articles/6182976.html 总结以下就是，SQLite是变长存储，有个功能叫vacuum，默认不会自动运行。不开启这个auto-vacuum时，从SQLite删除数据后，未使用的磁盘空间会被添加到一个内在的“空闲列表”中，用于存储下次插入的数据，提高效率，磁盘空间没有丢失，但也不向操作系统返回磁盘空间，这就导致删除数据乃至清空整个数据库后，数据文件大小没有缩小。 解决方法： 一是手动执行vacuum命令，执行方法是在sql命令行输入vacuum;无需参数，即可清空空闲列表。需要使用两倍于数据库文件的空间，也需要耗时。 二是在建表前开启自动清空，这样在每次删除时会数据库文件会自动收缩大小。但这种方式，只会从数据库文件中截断空闲列表的页，不会回收数据库中的碎片，也不会向vacuum命令那样重新整理数据库内容。实际上，由于需要在数据库文件中移动页，auto-vacuum会产生更多的碎片。 cmd.CommandText = &quot;PRAGMA auto_vacuum = 1;&quot; cmd.ExecuteNonQuery()要使用auto-vacuum，需要一个前提条件：数据库中需要存储一些额外的信息以记录它所跟踪的每个数据库页都找回其指针位置。 所以，auto-vacumm 必须在建表之前就开启。在一个表创建之后，就不能再开启或关闭 auto-vacumm。 两种方式在删除时都会有.db-journal后缀名的临时文件产生。","categories":[{"name":"tip","slug":"tip","permalink":"http://pointtang.github.io/categories/tip/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pointtang.github.io/tags/Android/"}]},{"title":"Git使用问题记录","slug":"Git使用问题记录","date":"2019-12-13T18:26:40.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/12/13/Git使用问题记录/","link":"","permalink":"http://pointtang.github.io/2019/12/13/Git%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"Git使用过程中各种各样的问题和想法。","text":"Git使用过程中各种各样的问题和想法。 AS输错Git账号密码Android Studio里的Git插件，第一次测试登入的时候输账号密码输错了，在Android Studio里就没有地方可以重新输入了。因为这个账号实际上保存到了Windows系统里，再做测试连接的时候，Android Studio会去读系统里保存的账号密码。 修改方式是：电脑——控制面板——用户账户——管理Windows凭据，找到git账号，编辑修改后，在Android Studio里重新测试连接。","categories":[{"name":"guide","slug":"guide","permalink":"http://pointtang.github.io/categories/guide/"}],"tags":[{"name":"git","slug":"git","permalink":"http://pointtang.github.io/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-13T10:48:39.082Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/12/13/hello-world/","link":"","permalink":"http://pointtang.github.io/2019/12/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"guide","slug":"guide","permalink":"http://pointtang.github.io/categories/guide/"}],"tags":[]},{"title":"使用CircleCI自动部署项目","slug":"Hexo博客搭建（三）使用CircleCI自动部署项目","date":"2019-11-01T17:46:50.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/11/01/Hexo博客搭建（三）使用CircleCI自动部署项目/","link":"","permalink":"http://pointtang.github.io/2019/11/01/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8CircleCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/","excerpt":"本篇介绍如何使用CircleCI自动部署博客到Github。","text":"本篇介绍如何使用CircleCI自动部署博客到Github。 有一天我需要更换电脑。然后我发现我github上的博客没有保存源码，只保存了自动生成的工程。 而且我想了想，我的博客部署一次好麻烦啊。 然后，在同事的帮助下，我尝试了Travis-CI和Circle CI，结果，Circle CI成功了。Travis-CI有一个坑爹的加密一直搞不对。 接下来，我只记录一下这个成功案例。 github新建一个blog仓库来放源文件。原来的pointtang.github.io用来放网页。 把旧电脑上的博客源码拷过来，新电脑上排排装环境，然后提交到blog仓库去。 发现的第一个问题： 我在新电脑上移动了一次目录，结果是本地的不能运行了。 我知道是node js里面什么东西依然在往我旧目录放，但是我找不到在哪里设置。 然后，卸载重装node js。电脑用户目录/AppData/Romaing/npm两个都删掉。博客项目根目录下的node_modules删掉。 重新走npm install流程。 发现的第二个问题： 提交后theme是空的。github仓库里，这个空的文件夹和默认的landscape图标都不一样。 这玩意是一个submodule，但是由于我原来是旧版本的git，用git clone命令加进去的主题，submodule就不正常了。 我找到了怎么解除submodule。 先把主题底下的_config.yml保存起来。 然后在github上，fork一个主题工程，分支什么的改好。 然后在本地解除错的submodule。先把他找出来，看看在不在。 $ git ls-files --stage | grep 16000这个命令可以列出来所有的submodule。如果有一行themes/3-hexo，那就是旧的，错的。然后先把它删掉。 $ git rm --cached themes/3-hexo下一步，用submodule来管理。 $ git submodule add https://github.com/PointTang/hexo-theme-3-hexo.git themes/3-hexo再下一步，把主题的yml文件放回去。放到themes/3-hexo目录底下。 再下一步，cd到themes/3-hexo目录，把这个主题的内容提交一哈。然后push到远程仓库。 这一步过了，去github上检查，就能看到fork的仓库里最新的提交了。 再下一步，cd回blog目录，把整个工程提交一哈，这样关联的submodule就是最新的commit id了。 然后，开始准备用Circle CI。 先去操作一下github。 在右上角Settings -&gt; Develop Settings -&gt; Personal Access Token，新建一个token用来部署。把这个token复制存起来备用。 勾选repo有关的就好。 再去操作一下Circle CI。 先到https://circleci.com/，右上角有一个Go to app的，用github账号登录。 然后关联一下blog工程。 左边第一个选Jobs，然后看到blog旁边有一个设置按钮，点进去，翻到环境变量Environment Variables，把这几个配上： GH_EMAIL 填github的邮箱 GH_USER 填github的用户名 GH_REF 填github要作为页面显示的那个项目地址，不带前面的https:// GH_TOKEN 填刚刚生成的token 再写一下本地工程里的Circle CI脚本。 工程根目录建一个文件夹，名字是.circleci，文件夹里面有一个文件，名字是config.yml。 文件内容照着抄。 version: 2 jobs: generate-page: docker: - image: node:8.11.1 steps: - checkout - run: name: 安装hexo command: npm install -g hexo-cli - run: name: 安装依赖 command: npm install - run: name: 更新关联 command: | echo &quot;submodule init.&quot; git submodule init echo &quot;submodule update.&quot; git submodule update - run: name: 生成页面 command: hexo generate - run: name: 部署Github Pages command: | cd public ls git init git config user.name &quot;$GH_USER&quot; git config user.email &quot;$GH_EMAIL&quot; git add . git commit -m &quot;update&quot; git push --force --quiet &quot;https://$GH_TOKEN@$GH_REF&quot; master echo &#39;deploy success&#39; workflows: version: 2 build-deploy: jobs: - generate-page: filters: branches: only: master写完提交一下。 然后去CircleCI查看Job，会看到这次提交的自动运行。","categories":[{"name":"guide","slug":"guide","permalink":"http://pointtang.github.io/categories/guide/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://pointtang.github.io/tags/hexo/"}]},{"title":"PHP（二）时间日期及数据库","slug":"PHP（二）时间日期及数据库","date":"2019-09-12T16:57:37.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/09/12/PHP（二）时间日期及数据库/","link":"","permalink":"http://pointtang.github.io/2019/09/12/PHP%EF%BC%88%E4%BA%8C%EF%BC%89%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"本篇记录PHP使用过程中用过的时间日期处理和数据库相关代码。","text":"本篇记录PHP使用过程中用过的时间日期处理和数据库相关代码。 PHP的数据库操作参考手册点这里。 PHP的时间日期操作参考手册点这里。 什么是时间戳时间戳是一个时区无关的量。 地球上分为24个时区，每个时区都有各自的时间，但同一时刻所有时区距离某一标准时间的差值是一致的，这个标准差值就是时间戳。 标准时间一般认为是格林威治时间1970年01月01日00时00分00秒，即0区时间1970-01-01 00:00:00，对应到北京时间是+8区时间1970-01-01 08:00:00。 PHP和MySQL中的时间戳都是10位，以秒为单位，在部分其他系统中，时间戳是13位，以毫秒为单位。 时间戳最远表示的时间是2038年，十位时间戳2147483647表示格林威治时间2038-01-19 11:14:07。 默认时区区别PHP的时区默认是0区格林威治标准时区。 MySQL的时区默认是系统设置时区。 PHP获取当前时间戳PHP使用time()方法获取当前时间戳，适用于PHP 4+。 PHP获取当前日期时间获取当前时间使用date(&#39;Y-m-d H:m:s&#39;)方法。这个方法拿到的永远是0时区的时间。 获取当前时区的时间 先设置date环境变量，参考 date_default_timezone_set() 。设置东八区使用:date_default_timezone_set(&quot;PRC&quot;);其中PRC是中华人民共和国（The People’s Republic of China）的简称。 再使用date方法获取当前时间：date(&#39;Y-m-d H:i:s&#39;)显示格式为2019-09-15 17:45:27 MySQL写入时间戳MySQL在建表时把字段类型设置成timestamp，默认值设为CURRENT_TIMESTAMP即可保存时间戳。 勾选根据当前时间戳更新，则每次更新记录时都会更新时间戳，不勾选，则记录创建时的时间戳。两种情况下建表SQL语句示例如下： CREATE TABLE `t_auth_v0` ( `F_MACADDRESS` varchar(12) NOT NULL, `F_INIT_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `F_TIMES` int(4) NOT NULL, PRIMARY KEY (`F_MACADDRESS`) ) CREATE TABLE `t_auth_v0` ( `F_MACADDRESS` varchar(12) NOT NULL, `F_INIT_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `F_TIMES` int(4) NOT NULL, PRIMARY KEY (`F_MACADDRESS`) ) MySQL读取时间戳MySQL中直接查询timestamp字段时，如果不设置查询Unix时间戳，会按照系统当前时区把存储的timestamp类型转换成可读的时间。时间格式示例： 2019-09-11 12:22:23 示例查询语句： SELECT F_MACADDRESS, F_INIT_TIME, F_TIMES FROM t_auth_v0 WHERE F_MACADDRESS=&#39;000000000000&#39; SELECT F_MACADDRESS, UNIX_TIMESTAMP(F_INIT_TIME), F_TIMES FROM t_auth_v0 WHERE F_MACADDRESS=&#39;000000000000&#39;MySQL在时间戳字段上有UNIX_TIMESTAMP方法和FROM_UNIXTIME方法。由于我们时间戳均为自动生成，此处不再赘述。","categories":[{"name":"tip","slug":"tip","permalink":"http://pointtang.github.io/categories/tip/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://pointtang.github.io/tags/PHP/"},{"name":"SQL","slug":"SQL","permalink":"http://pointtang.github.io/tags/SQL/"}]},{"title":"Hexo博客搭建（二）","slug":"Hexo博客搭建（二）","date":"2019-08-02T16:53:28.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/08/02/Hexo博客搭建（二）/","link":"","permalink":"http://pointtang.github.io/2019/08/02/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"本篇介绍Hexo增加新文章的基础命令。","text":"本篇介绍Hexo增加新文章的基础命令。 新增名为Hello的文章命令： hexo new hello该命令会在 source/_posts 目录下生成一个 hello.md 文件 给文章配置属性title: Hexo博客搭建（二） date: 2019-08-02 16:53:28 tags: [hexo] category: [guide]其中： tags 对应上一篇里的 tags ，文件目录在 source/tags/ 。如果需要多个标签，则用逗号分隔，如： tags: [PHP,SQL]category 对应上一篇里生成的 categories ，文件目录在 source/categories/ 。 实用命令hexo clean # 清除已经生成的缓存文件，这个操作会删除public目录下所有的文件。 # 因此推荐把头像也在source目录底下放一份。g命令会自动生成到public目录去。 hexo g # generate, 生成静态文件，从source到public。 hexo s # 启动本地服务器 hexo d # 部署到远程服务器，如github。","categories":[{"name":"guide","slug":"guide","permalink":"http://pointtang.github.io/categories/guide/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://pointtang.github.io/tags/hexo/"}]},{"title":"时间、时区、时间戳","slug":"时间、时区、时间戳","date":"2019-01-07T18:51:40.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2019/01/07/时间、时区、时间戳/","link":"","permalink":"http://pointtang.github.io/2019/01/07/%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E5%8C%BA%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3/","excerpt":"最近遇到转换时间戳的需求，本篇记录时间、时区、时间戳等概念，并提供一个初级的换算工具类。","text":"最近遇到转换时间戳的需求，本篇记录时间、时区、时间戳等概念，并提供一个初级的换算工具类。 说明时间戳是一个很神奇的东西，地球上任何一个位置，此时此刻，时间戳都是一致的，然而时间就不一样了，东八区早上九点的时候，伦敦0区是当天凌晨一点，在跨越了日期线的时区，连日期都会不一致。而我们的项目提供给全球客户，因此，使用时间戳就很有必要了。 Unix时间戳，长度是10位数字。但是在安卓里获取到的当前时间戳会有13位，用时间戳来设置当前时间的时候也需要是13位。 （安卓有一个设置系统时间的方法，代码如下，传一个13位的时间戳进去） SystemClock.setCurrentTimeMillis(timestamp);代码转换的工具类代码如下。是写给安卓测试的，但其实用的都是标准Java接口。 package com.point.pointutils; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; import java.util.TimeZone; /** * Created by Point on 2019/1/7. */ public class TimeUtils { /** * 获取当前系统显示的时间，格式为 2019-01-07 14:00:00 * @return 当前系统显示的时间 */ public static String getLocalTime(){ SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()); return format.format(new Date()); } /** * 获取当前系统设置的时区 * @return */ public static String getTimeZone(){ return TimeZone.getDefault().getID(); } /** * 将指定时区的指定时间转换为Unix时间戳 * @param time 待转换的时间 * @param timezone 待转换的时间的时区 * @return Unix时间戳 */ public static String getTimeStamp(String time, String timezone){ String timestamp = &quot;&quot;; DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); format.setTimeZone(TimeZone.getTimeZone(timezone)); try { Date date = format.parse(time); timestamp = format.format(date); } catch (ParseException e) { e.printStackTrace(); } return timestamp; } /** * 将指定时间戳转换成指定时区的时间 * @param timestamp 待转换的时间戳，10位数字 * @param timezone 指定时区的ZoneID，可用TimeZone.getAvailableIDs()查询，建议使用本机时区 * @return 转换后的时间 */ public static String getTime(String timestamp, String timezone){ SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); format.setTimeZone(TimeZone.getTimeZone(timezone)); return format.format(new Date(Long.parseLong(timestamp)*1000)); } }","categories":[{"name":"util","slug":"util","permalink":"http://pointtang.github.io/categories/util/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://pointtang.github.io/tags/Java/"}]},{"title":"PHP（一）字符串记录","slug":"PHP（一）字符串记录","date":"2018-07-31T16:37:47.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2018/07/31/PHP（一）字符串记录/","link":"","permalink":"http://pointtang.github.io/2018/07/31/PHP%EF%BC%88%E4%B8%80%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/","excerpt":"本篇记录PHP使用过程中用过的字符串处理方法。","text":"本篇记录PHP使用过程中用过的字符串处理方法。 PHP的String参考手册点这里。 判断指定开头PHP没有startWith方法，但是可以查下标来判断。strpos() 函数查找字符串在另一字符串中第一次出现的位置。 if(strpos(&#39;111字符串的开头是&#39;, &#39;111&#39; )===0){ echo &#39;字符串开头是111&#39;; }判断指定结尾PHP同样没有endWith方法，但是可以用查找最后一次出现的位置来判断。strrchr()函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 if(strrchr(&#39;字符串的结尾是222&#39;,&quot;222&quot;)==&quot;.GC&quot;){ echo &#39;字符串结尾是222&#39;; } 字符串替换PHP字符串替换使用str_replace方法。str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。str_ireplace() 函数以其他字符替换字符串中的一些字符（不区分大小写）。 $str = str_replace (&#39;A&#39;,&#39;B&#39;,&#39;把字符串里的A替换成B&#39;);这个方法建议去看详情，我用的比较简单。 字符串去掉指定开头PHP有ltrim方法去掉左侧的指定字符。不填第二个参数则去掉空格，不管有几个。ltrim() 函数移除字符串左侧的空白字符或其他预定义字符。 echo ltrim(&#39;接下来去掉这个字符串开头的接下来&#39;,&#39;接下来&#39;);字符串去掉指定结尾PHP有rtrim方法去掉右侧的指定字符。不填第二个参数则去掉空格，不管有几个。rtrim() 函数移除字符串右侧的空白字符或其他预定义字符。 echo rtrim(&#39;接下来去掉这个字符串结尾的接下来&#39;,&#39;接下来&#39;);字符串去掉指定开头和结尾PHP有trim方法去掉两侧的指定字符。不填第二个参数则去掉空格，不管有几个。trim() 函数移除字符串两侧的空白字符或其他预定义字符。 echo rtrim(&#39;接下来去掉这个字符串两侧的接下来&#39;,&#39;接下来&#39;);","categories":[{"name":"tip","slug":"tip","permalink":"http://pointtang.github.io/categories/tip/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://pointtang.github.io/tags/PHP/"}]},{"title":"SQL语句记录","slug":"SQL语句记录","date":"2018-05-29T15:21:39.000Z","updated":"2019-12-13T10:48:39.082Z","comments":true,"path":"2018/05/29/SQL语句记录/","link":"","permalink":"http://pointtang.github.io/2018/05/29/SQL%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/","excerpt":"本篇用于记录SQL语句的不常见玩法，基本的增删改查不写。","text":"本篇用于记录SQL语句的不常见玩法，基本的增删改查不写。 REPLACE这次遇到的需求是这样的：新到一批数据，批量导入了数据库，然后老大后悔了，原定的某个字段以NSW开头，现在想批量改成NWG开头，后面的字符不变。这个需求本来是打算写一段SQL代码，定义变量，然后取出来原来的，改掉，再重新插入。然后有哥们提示可以用Replace函数。 这个函数很简单，replace(列名, &#39;原关键字&#39;, &#39;新关键字&#39;)，可以套用在select和update里。套在select里，将只对查询结果进行replace，例如SELECT REPLACE (FU, &#39;NSW&#39;, &#39;NWG&#39;) FROM t_c;将在t_c表的查询结果里把FU字段的NSW替换为NWG，不影响原数据。套在update里，将对原数据进行replace，例如UPDATE t_s SET FU = REPLACE (FU, &#39;NSW&#39;, &#39;NWG&#39;);将对t_s表里的FU字段的NSW全部替换为NWG。 replace还有其他的用法，等需求到了用的时候再说，至少先明白有这个关键字/函数。","categories":[{"name":"tip","slug":"tip","permalink":"http://pointtang.github.io/categories/tip/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://pointtang.github.io/tags/SQL/"}]},{"title":"Hexo博客搭建（一）","slug":"Hexo博客搭建（一）","date":"2018-05-21T16:08:33.000Z","updated":"2019-12-13T10:48:39.082Z","comments":false,"path":"2018/05/21/Hexo博客搭建（一）/","link":"","permalink":"http://pointtang.github.io/2018/05/21/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"本篇记录如何从零开始搭建一个博客，以及我起手遇到过的问题。 Hexo官方向导讲解了如何去搭建环境，这里照着教程做就好。其中可能遇到的问题我在CSDN博客里也讲了很多，这篇会挑一些讲。","text":"本篇记录如何从零开始搭建一个博客，以及我起手遇到过的问题。 Hexo官方向导讲解了如何去搭建环境，这里照着教程做就好。其中可能遇到的问题我在CSDN博客里也讲了很多，这篇会挑一些讲。 配置及部署在安装完环境、init出第一个博客项目之后，有一些配置需要手动更改，文件是根目录的_config.yml文件。这个文件后面会在其他地方也看到，注意看清楚目录位置。 这个文件可以改一些东西，首先是第一部分，Site，可以修改标题、副标题、说明等等大面上的内容，改过之后至少一眼看着这个博客就是你自己的了。 下面大多数保持不动，然后再修改一个地方，最后的deploy，这个地方是项目部署的位置，我在乐乐的代码里看到，他一个项目可以部署到两个地方，这里看个人需要。我在他的代码里看到，如果部署两个，只需要在每一个的type前面加一个减号“-”就好了。 deploy: type: git repository: git@github.com:PointTang/PointTang.github.io.git branch: master 博客项目搭好以后，在本地使用hexo s命令启动，会默认启动到4000端口，然后可以使用localhost:4000请求访问。 启动好以后，想再放到github去，需要先停掉本地的服务，再去命令行hexo g和hexo d。 有一点要说的是，hexo clean命令，会清空根目录的/public目录，然后hexo g命令又会重新生成/public目录。 自定义准备工作#不管用什么主题，有一些模块大体是通用的。比如分类、标签、关于我之类的目录，在项目初始化的时候并不会自动创建。 准备这些文件有两种方式，一种是到项目source目录底下手动创建文件夹，再手动创建index.md文件，另一种就是我喜欢的命令行方式。 我创建了“关于我”“分类”“标签”这三个东西： 命令hexo new page &quot;tags&quot;创建标签md文件，然后在根目录/source/tags/index.md中修改type属性为&quot;tags&quot;。 命令hexo new page &quot;categories&quot;创建分类md文件，然后在根目录/source/categories/index.md中修改type属性为&quot;categories&quot;。 关于我没有直接用命令行创建，我在根目录/source/下直接新建了about文件夹，在about文件里新建了index.md文件，然后修改页面内容。 主题更换#总是不喜欢用系统默认主题，官方主题列表在这里，也说明了怎么更换主题。 主题不好挑的话，随便知乎或者别的搜一下就能看到有推荐，还是排排列好图的那种。 主题配置在哪里改，这是另一个_config.yml文件了，在/themes/jacman/目录底下。这个文件修改的时候，看着挑选的主题的修改说明就好了。 有图标什么的修改更换，也都放在/source目录底下新建一个img文件夹，可以换主题的时候通用，还能不被clean命令清除掉。 发布上线所有的更改做完都可以通过本地hexo s直接预览，预览成功后停掉本地服务，使用hexo d和hexo g命令上线到github去，就可以看到更改了。 后记成长，就从这里开始吧。做宇宙中一个小点，也要做更好的点。 I’m Point.","categories":[{"name":"guide","slug":"guide","permalink":"http://pointtang.github.io/categories/guide/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://pointtang.github.io/tags/hexo/"}]}]}